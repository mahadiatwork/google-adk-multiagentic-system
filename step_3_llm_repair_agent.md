# Step 3: LLM RepairAgent Integration

## Objective
Integrate a real LLM-based `RepairAgent` into the self-healing loop. This replaces the simulated "patched" comment with actual code fixes generated by an AI model (OpenRouter), closing the loop between execution, error analysis, and code generation.

## Functional Requirements
- **Error Context**: Capture `stderr` and the full source code of the failing file.
- **LLM Intervention**: Call the `MODEL_PROGRAMMER` (from `.env`) via OpenRouter with a targeted repair prompt.
- **Sanitization**: Pass the LLM response through `extract_code_block()` to ensure only pure Python is saved.
- **File Update**: Overwrite the original file with the fixed version.
- **Loop Continuity**: The `while` loop continues, allowing multiple repair attempts (up to `max_retries`).

## Implementation

```python
import os
from src.agents.openrouter_agent import OpenRouterAgent
from src.tools.code_manager import extract_code_block

def call_repair_agent(filepath: str, error_msg: str) -> str:
    """
    Calls the LLM to fix the code based on the provided error message.
    """
    with open(filepath, 'r') as f:
        buggy_code = f.read()

    model = os.getenv("MODEL_PROGRAMMER", "google/gemini-2.0-flash")
    agent = OpenRouterAgent(
        name="RepairAgent",
        model=model,
        instruction="You are an expert Python debugger."
    )

    prompt = (
        f"The following Python code crashed with this error:\n\n{error_msg}\n\n"
        f"Here is the buggy code:\n\n{buggy_code}\n\n"
        f"Please fix the code to resolve this exact error. "
        f"Output ONLY the fully corrected Python code inside a markdown block. "
        f"Do not explain the fix."
    )

    response = agent.query(prompt)
    fixed_code = extract_code_block(response)
    return fixed_code
```

## How to Test
1. **Prepare Failing Script**: Create `bad_code.py` with the intentional `ZeroDivisionError`.
2. **Execute Healer**: Run the updated `execute_and_heal('bad_code.py')`.
3. **Expectation**:
   - [Attempt 1] fails.
   - Terminal shows: `Sending to RepairAgent...`
   - Terminal shows: `API call to OpenRouter...`
   - The file `bad_code.py` is overwritten with fixed code (e.g., `print(1 / 1)` or error handling).
   - [Attempt 2] succeeds.
   - Terminal shows: `‚úÖ Success!`.

## Verification Status
- [x] Logic implemented in `src/tools/test_runner.py`
- [x] **The Bouncer**: `extract_code_block` correctly sanitizes LLM output before overwriting files.
- [x] Successful fix of `bad_code.py` verified (First-shot success on Attempt 2).
- [x] All 5 unit tests for `extract_code_block` still pass

### Execution Trace Summary
```text
--- Testing Self-Healing with bad_code.py ---

[Attempt 1] Executing: bad_code.py
Starting bad code...
‚ùå Error caught: Traceback ... ZeroDivisionError: division by zero. Sending to RepairAgent...
ü§ñ Calling RepairAgent (qwen/qwen-2.5-coder-32b-instruct) to fix the code...
DEBUG: Raw response length: 245
DEBUG: Extracted code (first 50 chars): print('Starting bad code...') try:     print(1 / 0...
‚ú® Code fixed and saved.

[Attempt 2] Executing: bad_code.py
Starting bad code...
Attempted to divide by zero, which is not allowed. 
‚úÖ Success executing bad_code.py

Final Success Status: True
```

### Execution Trace Summary
```text
--- Testing Self-Healing with bad_code.py ---

[Attempt 1] Executing: bad_code.py
Starting bad code...
‚ùå Error caught: Traceback ... ZeroDivisionError: division by zero. Sending to RepairAgent...
ü§ñ Calling RepairAgent (qwen/qwen-2.5-coder-32b-instruct) to fix the code...
‚ú® Code fixed and saved.

[Attempt 2] Executing: bad_code.py
Starting bad code...
‚úÖ Success executing bad_code.py
Output: Hello, World!

Final Success Status: True
```
